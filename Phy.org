#+INCLUDE: "preamble.org"

#+TITLE: Physical Layer 
#+AUTHOR: Mo, Yilin
#+DATE: Oct 2020 

#+KEYWORDS: physical layer
#+DESCRIPTION: physical layer for iot course


#+BEGIN_SRC ipython :session :exports none
from bokeh.resources import CDN
from bokeh.plotting import figure, show
from bokeh.embed import autoload_static
from bokeh.layouts import gridplot
from bokeh.models import Range1d
from numpy import *

width = 1200
height = 600


def step_func(x, x0, y0):
    index = argsort(abs(x - 0.5 - x0))[0]
    return y0[index]
#+END_SRC

#+RESULTS:
: # Out[1]:

* Introduction
  
** Core Questions
   TODO
** Learning Objectives
   TODO
** Table of Contents
   :PROPERTIES:
   :UNNUMBERED: notoc
   :END:
#+REVEAL_TOC: headlines 1

* Overview

** OSI 7-Layer Network Model

    {{{revealimg("./figures/osimodel.meta",t,"60vh")}}}

** OSI Physical Layer
- The physical layer defines the means of transmitting raw bits over a physical data link connecting network nodes. 
- Deals with accessing the physical medium
  - Mechanical characteristics
  - Electrical characteristics
  - Functional characteristics
  - Procedural characteristics
    
** Wireless PHY protocols
  {{{revealimg("./figures/wirelesscommunication.meta","Various wireless communication protocols and categories designed for different ranges\, data rates\, and use cases","60vh",nil,'none)}}}
   
** Electromagnetic Spectrum
 
    {{{revealimg("./figures/emspectrum.meta",t,"60vh")}}}
 
** Radio Frequency (RF) Signal
 
    {{{revealimg("./figures/ituradioband.meta",t,"60vh")}}}
    
** RF Band Allocation

    {{{revealimg("./figures/usfreqallocation.meta",t,"60vh")}}}

- Frequency band is a very *rare* & *important* resource!
   
** ISM Band
  
- Radio spectrum reserved internationally for industrial, scientific and medical (ISM) purposes 
  - e.g., microwave ovens
- Fastest-growing use for low power wireless communications systems
  - e.g., WiFi, Bluetooth, Zigbee, LoRa
- Communications equipment must tolerate interference generated by ISM applications
| Frequency Range   | Center Frequency | Bandwidth | Availability |
| 433.05~434.79 MHz | 433.92 MHz       | 1.74 MHz  | Region 1     |
| 902~928 MHz       | 915 MHz          | 26 MHz    | Region 2     |
| 2.4~2.5 GHz       | 2.45 GHz         | 100 MHz   | Worldwide    |
| 5.725~5.875 GHz   | 5.8 GHz          | 150 MHz   | Worldwide    |

* Digital Modulation and Demodulation

** Modulation Overview
- Modulation is the process of varying one or more properties of a periodic waveform, called the *carrier signal*, with a *modulating signal* that typically contains information to be transmitted. 
- In digital modulation, an *analog carrier signal* is modulated by a *discrete signal*.
- The most fundamental digital modulation techniques are based on keying:
  - ASK (amplitude-shift keying): *a finite number of amplitudes* are used.
  - FSK (frequency-shift keying): *a finite number of frequencies* are used.
  - PSK (phase-shift keying): *a finite number of phases* are used.
  - QAM (quadrature amplitude modulation): *a finite number of at least two phases and at least two amplitudes* are used.

*** Rectangle and Sinc Function

- The simplest digital signal is a rectangle function:
\[rect(x) = \begin{cases} 1 & x \in [-0.5,0.5]\\ 0 & otherwise \end{cases}.\]  
- Fourier Transform:
\[F(\omega ) = \int_{-\infty}^\infty f(t) \exp(2\pi i  \omega t)dt.\]
- The FT of rectangle function is (normalized) sinc function
\[sinc(\omega) = \frac{\sin(\pi*\omega)}{\pi*\omega}.\]

*** Rectangle and Sinc Function

#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/rect.js"

x = linspace(-2,2,5)
y = [1 if z <= 0.5 and z >= -0.5 else 0 for z in x]
p1 = figure(title = "Time Domain")
p1.step(x, y, line_width=2, mode="center")

x = linspace(-8,8,400)  
y = sinc(x)
p2 = figure(title = "Frequence Domain")
p2.line(x,y, line_width=2)

p = gridplot([p1, p2], ncols = 2, plot_width = width//2, plot_height = height)
js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/rect.js" id="cf11430c-d27a-4ade-89e0-793926ad0e4b"></script>
#+end_export

*** Energy Spectrum of Rectangle Function
 
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/psd.js"
x = linspace(-5,5,400)  
y = sinc(x)
p = figure(title = "Energy Spectrum", plot_width = width, plot_height = height )
p.line(x, y**2, line_width=2)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/psd.js" id="d4485f35-7b00-40e1-9caa-baa9e9de33c6"></script>
#+end_export

- Most of the energy are located inside the passband of \(\pm 1Hz\).
   
*** Properties of Fourier Transform
    
|                    | Time Domain                   | Frequency Domain                        |
| Linear Combination | \(a\times f(t)+b\times g(t)\) | \(a\times F(\omega)+b\times G(\omega)\) |
| Multiplication     | \( f(t)\times g(t)  \)        | \(F(\omega) * G(\omega)\)               |
| Delay              | \(f(t-\tau)\)                 |  \(\exp(-2\pi i \tau \omega) F(\omega)\) |

*** Modulation

- If we multiply the baseband signal (\(rect(t)\)) with a carrier signal (\(cos(2\pi f_0 t)\))

\[S(t) = rect(t)\times \cos (2\pi f_0 t). \]
- In frequency domain, the signal will be centered around the carrier frequency \(f_0\)
- Most of the energy is allocated inside \(f_0\pm 1\).
- If we reduce the symbol time from \(1s\) to \(\tau s\):
  - The modulated signal will still be centered around \(f_0\)
  - However, the zero crossing will happen at \(f_0 \pm 1/\tau\).
*** Modulation

#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/modulation.js"

x = linspace(-2,2,5)
y = [1 if z <= 0.5 and z >= -0.5 else 0 for z in x]
p1 = figure(title = "Time Domain")
p1.step(x, y, line_width=2, mode="center")

x = linspace(-20,20,400)  
y = sinc(x)
p2 = figure(title = "Frequence Domain")
p2.line(x, y, line_width=2)

x = linspace(-2,2,200)
y = cos(10*pi*x)
p3 = figure(title = "Time Domain")
p3.line(x,y, line_width=2)

x = [-5,5]
y = [.5, .5]
p4 = figure(title = "Frequence Domain")
p4.triangle(x, y, size=20)
p4.segment(x0 = x, y0 = y, x1 = x, y1 = [0,0], line_width=2)

x = linspace(-2,2,200)
y = [cos(10*pi*z) if z <= 0.5 and z >= -0.5 else 0 for z in x]
p5 = figure(title = "Time Domain")
p5.line(x, y, line_width=2)

x = linspace(-20,20,400)
y = sinc(x-5) + sinc(x+5)
p6 = figure(title = "Frequency Domain")
p6.line(x, y/2, line_width=2)

p = gridplot([p1, p3, p5, p2, p4, p6], ncols = 3, plot_width = width//3, plot_height = height//2)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/modulation.js" id="54c057fa-fc48-4ab5-bd8d-10a3a846fda8"></script>
#+end_export

*** Demodulation
- The baseband signal can be recovered as
\begin{align*}
S(t) \times \cos(2\pi f_0 t) &= rect(t) \times \cos^2(2\pi f_0 t)\\
&= \frac{1}{2} rect(t) \times \left[1+\cos(4\pi f_0 t)\right] 
\end{align*}
- A low pass filter can be used in order to:
  - Filter out the high frequency \(rect(t) \times \cos(4\pi f_0 t)\) component;
  - And recover the baseband signal \(rect(t)\).

*** Demodulation
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/demodulation.js"

x = linspace(-2,2,5)
y = [1 if z <= 0.5 and z >= -0.5 else 0 for z in x]
p1 = figure(title = "Time Domain")
p1.step(x, y, line_width=2, mode="center")

x = linspace(-20,20,400)  
y = sinc(x)
p2 = figure(title = "Frequence Domain")
p2.line(x, y, line_width=2)

x = linspace(-2,2,200)
y = [cos(10*pi*z) if z <= 0.5 and z >= -0.5 else 0 for z in x]
p3 = figure(title = "Time Domain")
p3.line(x, y, line_width=2)

x = linspace(-20,20,400)
y = sinc(x-5) + sinc(x+5)
p4 = figure(title = "Frequency Domain")
p4.line(x, y/2, line_width=2)

x = linspace(-2,2,400)
y = [cos(10*pi*z)**2 if z <= 0.5 and z >= -0.5 else 0 for z in x]
p5 = figure(title = "Time Domain")
p5.line(x, y, line_width=2)

x = linspace(-20,20,400)
y = sinc(x-10) + 2*sinc(x) +  sinc(x+10)
p6 = figure(title = "Frequency Domain")
p6.line(x, y/2, line_width=2)

p = gridplot([p1, p3, p5, p2, p4, p6], ncols = 3, plot_width = width//3, plot_height = height//2)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/demodulation.js" id="3b631c8c-46cf-4e19-804f-995e5130cc2d"></script>
#+end_export

** Amplitude-Shift Keying
   
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/ask.js"
x0 = linspace(0, 12, 13)
y0 = [0,0,1,1,0,1,0,0,0,1,1,0,0,0]
p1 = figure(title = "Baseband Signal")
p1.step(x0, y0, line_width=2, mode="after")

x = linspace(0, 12, 241)
y = [step_func(p, x0, y0) * sin(2*pi*p) for p in x]
p2 = figure(title = "On-off Keying")
p2.line(x, y, line_width=2)

x1 = linspace(0, 11, 12)
y1 = [0,0,3,3,1,1,0,0,1,1,2,2]
y = [(step_func(p, x1, y1)+1) * sin(2*pi*p) for p in x]
p3 = figure(title = "4-ASK")
p3.line(x, y, line_width=2)

p = gridplot([p1, p2, p3], ncols = 1, plot_width = width, plot_height = height//3)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/ask.js" id="da356ad6-26c1-48f0-8728-642304f25b96"></script>
BokehUserWarning: ColumnDataSource's columns must be of the same length. Current lengths: ('x', 13), ('y', 14)
#+end_export

*** Amplitude-Shift Keying
- We are allocated with a frequency band between 200-300kHz. If we use 4-ASK modulation scheme: 
  - What is the carrier frequency?
  - What is the symbol rate per second?
  - What is the bit rate per second?

** Frequency-Shift Keying
   

#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/fsk.js"
x0 = linspace(0, 12, 13)
y0 = [0,0,1,1,0,1,0,0,0,1,1,0,0,0]
p1 = figure(title = "Baseband Signal")
p1.step(x0, y0, line_width=2, mode="after")

x = linspace(0, 12, 241)
y = [step_func(p, x0, y0) * sin(4*pi*p) + (1-step_func(p, x0, y0)) * sin(2*pi*p) for p in x]
p2 = figure(title = "Frequency-Shift Keying")
p2.line(x, y, line_width=2)

p = gridplot([p1, p2], ncols = 1, plot_width = width, plot_height = height//2)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/fsk.js" id="88b8654e-7e4e-46b9-a4a1-68fc6dd344be"></script>
BokehUserWarning: ColumnDataSource's columns must be of the same length. Current lengths: ('x', 13), ('y', 14)
#+end_export

*** Frequency-Shift Keying
- In practice, we can smooth the digital signal 
  - e.g., by Gaussian filter
  - the frequency changes more smoothly rather than instantaneously
  - to reduce sideband power
- We are allocated with a frequency band between 200-300kHz. If we use FSK modulation scheme: 
  - What are the sub-carrier frequencies?
  - What is the bit rate per second?

** Phase-Shift Keying
   
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/psk.js"
x0 = linspace(0, 12, 13)
y0 = [0,0,1,1,0,1,0,0,0,1,1,0,0,0]
p1 = figure(title = "Baseband Signal")
p1.step(x0, y0, line_width=2, mode="after")

x = linspace(0, 12, 241)
y = [(1-2*step_func(p, x0, y0)) * sin(2*pi*p) for p in x]
p2 = figure(title = "Binary PSK")
p2.line(x, y, line_width=2)

x1 = linspace(0, 11, 12)
y1 = [0,0,3,3,1,1,0,0,1,1,2,2]
y = [sin(2*pi*p+pi/4 + pi/2*step_func(p,x1,y1)) for p in x]
p3 = figure(title = "Quadrature-PSK")
p3.line(x, y, line_width=2)

p = gridplot([p1, p2, p3], ncols = 1, plot_width = width, plot_height = height//3)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/psk.js" id="a87028c8-7659-4ebc-9ae9-14e0bbcfa96f"></script>
BokehUserWarning: ColumnDataSource's columns must be of the same length. Current lengths: ('x', 13), ('y', 14)
#+end_export
 
** QAM
 
*** Constellation Diagram
   
- We could draw the amplitude and phase of the symbol on the complex plane:
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/constellation.js"
x = [0,1]
y = [0,0]
rx = cos(linspace(0,2*pi,200))
ry = sin(linspace(0,2*pi,200))
p1 = figure(title = "OOK")
p1.circle(x, y, size = 20)
p1.line(rx, ry, line_dash = 'dotted')

x = [1,-1]
y = [0,0]
p2 = figure(title = "BPSK")
p2.circle(x, y, size = 20)
p2.line(rx, ry, line_dash = 'dotted')

x = cos(linspace(pi/4,pi/4*7,4))
y = sin(linspace(pi/4,pi/4*7,4))
p3 = figure(title = "QPSK")
p3.circle(x, y, size = 20)
p3.line(rx, ry, line_dash = 'dotted')

p = gridplot([p1, p2, p3], ncols = 3, plot_width = width//3, plot_height = width//3)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/constellation.js" id="f8b9e07a-9b6f-4540-aa3f-71f4fd4e6e73"></script>
#+end_export

*** Quadrature Amplitude Modulation (QAM)
- We could combine multiple amplitude and multiple phase together to form a constellation
- The most common ones are 16, 64, 256 QAM
  - each symbol carries 4, 6, 8 bits repsectively
  
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/qam.js"
x = linspace(-3,3,4)
y = linspace(-3,3,4)
xx, yy = meshgrid(x, y)
p1 = figure(title = "16-QAM")
p1.circle(xx.flatten(), yy.flatten(), size = 20)

x = linspace(-5,5,6)
y = linspace(-5,5,6)
xx, yy = meshgrid(x, y)
p2 = figure(title = "64-QAM")
p2.circle(xx.flatten(), yy.flatten(), size = 10)

x = linspace(-7,7,8)
y = linspace(-7,7,8)
xx, yy = meshgrid(x, y)
p3 = figure(title = "256-QAM")
p3.circle(xx.flatten(), yy.flatten(), size = 10)
p = gridplot([p1, p2, p3], ncols = 3, plot_width = width//3, plot_height = width//3)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/qam.js" id="4510a8e9-34b4-4412-9bac-3aaed3661156"></script>
#+end_export

- For Wifi 6, up to 1024-QAM can be used depending on the channel quality
- Can we use "infinite"-QAM to transmit at "infinite" bit rate?

* Free Space Propagation Model
  
** Free Space Loss

*** Channel Impairments
- *Free space loss*
- *Noise*
- Fading 
  - Multi-path (Next Section)
- Atmospheric absorption

*** Free Space Transmission
    {{{revealimg("./figures/freespace.meta",t,"60vh")}}}

*** Friis Transmission Equation

- Friss Transmission Equation:
 \[\frac {P_{r}}{P_{t}}}=\left({\frac {A_{r}A_{t}}{d^{2}\lambda ^{2}}}\right).\]
- where:
  - \(P_{t}\) is the power fed into the transmitting antenna input terminals;
  - \(P_{r}\) is the power available at receiving antenna output terminals;
  - \(A_{r}\) is the effective aperture of the receiving antenna;
  - \(A_{t}\) is the effective aperture of the transmitting antenna;
  - \(d\) is the distance between antennas;
  - \(\lambda\) is the wavelength of the radio frequency;
- To increase signal strength at the receiving end:
  - Increase transmitting power; 
  - Decrease carrier frequency, distance;
  - Better antenna

** Noise
- Thermal Noise(John-Nyquist Noise)
  - Noise seen in switching circuits due to electrons
- Inter-modulation noise
  - Noise caused by signals at different frequencies on the same medium
- Crosstalk
  - coupling between signal paths
- Impulse Noise
  - Power spike (e.g. from thunder)

*** Thermal Noise

- White noise since it contains the same level of power at all frequencies
 \[N = ktB\]
- \(k\) is the Boltzmann’s constant: \(1.381\times 10^{-21} W/(K\cdot Hz)\),
- \(T\) is the absolute temperature in Kelvin, and
- \(B\) is the bandwidth.
- At room temperature, \(T = 290K\), the thermal noise power spectral density
  \(kT =  –174 dBm/Hz\)
- dBm is the ratio between the power and a reference of one milliwatt (mW), expressed in dB.
  - 0dBm = 1mW, 10dBm = 10mW, 20dBm = 100mW
- For 1MHz bandwidth, the power of the noise is
\(-174 + 10 log 1M= -114dBm\) or \(4\times 10^{-15}W\).

*** Thermal Noise

#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/thermalnoise.js"

from scipy import signal
t = linspace(0,5,501)
y = random.randn(len(t))
p1 = figure(title = 'White Noise')
p1.line(t,y)

f, Pxx_den = signal.welch(random.randn(100000), 1024, nperseg=1024)
p2 = figure(title = 'Power Spectra Density')
p2.line(f[1:-1],Pxx_den[1:-1])
p2.y_range=Range1d(0, max(Pxx_den))

p = gridplot([p1, p2], ncols = 1, plot_width = width, plot_height = height//2)
show(p)
js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/thermalnoise.js" id="6be8e08c-a9cd-4b71-be6f-9dd565fc7950"></script>
#+end_export

*** Constellation Diagram with Noise
    
#+BEGIN_leftcol

#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/qam2.js"
x = linspace(-3,3,4)
y = linspace(-3,3,4)
xx, yy = meshgrid(x, y)
p = figure(title = "16-QAM",  plot_width = width//3, plot_height = width//3)
p.circle(xx.flatten(), yy.flatten(), size = 20)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/qam2.js" id="15a910a6-2327-40f6-a149-02faa81499e9"></script>
#+end_export

#+END_leftcol

#+BEGIN_rightcol
    {{{revealimg("./figures/16qam.meta",t,"60vh")}}}
#+END_rightcol
 
** Shannon Channel Capacity Theorem

*** Basic of Detection Theory
- Assuming we are using BPSK:

#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/binarydetection.js"

x = [-1,1]
y = [0,0]
p = figure(title = "Detection of BPSK", plot_width = width, plot_height = height//2)
p.circle(x, y, size=10)

x = linspace(-3,3,121)
y = exp(-x**2/2)/sqrt(2*pi)

p.line(x-1, y, line_width=2)
p.line(x+1, y, line_width=2)
p.patch(x[-41:-1]-1, y[-41:-1], hatch_pattern="/")
p.patch(x[0:41]+1, y[0:41], hatch_pattern="\\")
show(p)
js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/binarydetection.js" id="ae0a1212-086f-419d-94f9-945cb583732e"></script>
#+end_export

- The probability of error is
\[P_e = Q\left(2\sqrt{SNR}\right),\]
- \(Q\) is the 


* Multi-Path Problem 
 
** Multi-path
   
*** Impairments
- Free space loss
- Noise
- Fading 
  - *Multi-path*
- Atmospheric absorption

*** Multi-path
- Multi-path: obstacles reflect signals so that multiple copies with varying delays are received
  - Reflection - occurs when signal encounters a surface that is large relative to the wavelength of the signal
  - Diffraction - occurs at the edge of an impenetrable body that is large compared to wavelength of radio wave
  - Scattering – occurs when incoming signal hits an object whose size in the order of the wavelength of the signal or less

*** Reflection/Diffraction/Scattering

*** Reflecting Wall Example

*** Coherent Bandwidth

*** Intersymbol Interference
    
*** Mobile Object
    
*** Coherent Time


* Diversity
  
** Time Diversity 
   
** Frequency Diversity   
   
** Frequency Hopping Spread Spectrum
   
** OFDM
   
** Chirp Spread Spectrum 
   
** CDMA
   
* Physical Layer Protocol
** Bluetooth LE
   
** IEEE 802.15.4
   
** IEEE 802.11

** Cellular System
   
** LoRa
  
* Conclusion
