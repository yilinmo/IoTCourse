#+INCLUDE: "preamble.org"

#+TITLE: Physical Layer 
#+AUTHOR: Mo, Yilin
#+DATE: Oct 2020 

#+KEYWORDS: physical layer
#+DESCRIPTION: physical layer for iot course

#+BEGIN_SRC ipython :session :exports none
from bokeh.resources import CDN
from bokeh.plotting import figure, show
from bokeh.embed import autoload_static
from bokeh.layouts import gridplot
from bokeh.models import Range1d
from numpy import *
from bokeh.palettes import Category10_10

width = 1200
height = 600


def step_func(x, x0, y0):
    index = argsort(abs(x - 0.5 - x0))[0]
    return y0[index]
#+END_SRC

#+RESULTS:
: # Out[1]:

* Introduction

** Core Questions
  
- What purpose does the physical layer serve in OSI network model?
- What is a frequency band for radio signal?
  - How can we modulate a baseband signal to fit in the frequency band?
- What is the fundamental limit for reliable data transmission?
- How does multi-path deteriorate the communication channel?
  - How to counter the multi-path effect using diversity?
- What considerations do we have for choosing PHY protocols?   
   
** Learning Objectives
   
- Definition of physical layer in the OSI network model
- Frequency band of radio signal
  - Digital modulation and demodulation  
- The capacity of a AWGN channel
- Coherence bandwidth and time due to multi-path
- Time/Space/Frequency diversity
- Various communication protocols and the comparison between them
   
** Table of Contents
   :PROPERTIES:
   :UNNUMBERED: notoc
   :END:
#+REVEAL_TOC: headlines 1

* Overview

** OSI 7-Layer Network Model

    {{{revealimg("./figures/osimodel.meta",t,"60vh")}}}

** OSI Physical Layer
- The physical layer defines the means of transmitting raw bits over a physical data link connecting network nodes. 
- Deals with accessing the physical medium
  - Mechanical characteristics
  - Electrical characteristics
  - Functional characteristics
  - Procedural characteristics
    
** Wireless PHY protocols
  {{{revealimg("./figures/wirelesscommunication.meta","Various wireless communication protocols and categories designed for different ranges\, data rates\, and use cases","60vh",nil,'none)}}}
   
** Electromagnetic Spectrum
 
    {{{revealimg("./figures/emspectrum.meta",t,"60vh")}}}
 
** Radio Frequency (RF) Signal
 
    {{{revealimg("./figures/ituradioband.meta",t,"60vh")}}}
    
** RF Band Allocation

    {{{revealimg("./figures/usfreqallocation.meta",t,"60vh")}}}

- Frequency band is a very *rare* & *important* resource!
   
** ISM Band
  
- Radio spectrum reserved internationally for industrial, scientific and medical (ISM) purposes 
  - e.g., microwave ovens
- Fastest-growing use for low power wireless communications systems
  - e.g., WiFi, Bluetooth, Zigbee, LoRa
- Communications equipment must tolerate interference generated by ISM applications
| Frequency Range   | Center Frequency | Bandwidth | Availability |
| 433.05~434.79 MHz | 433.92 MHz       | 1.74 MHz  | Region 1     |
| 902~928 MHz       | 915 MHz          | 26 MHz    | Region 2     |
| 2.4~2.5 GHz       | 2.45 GHz         | 100 MHz   | Worldwide    |
| 5.725~5.875 GHz   | 5.8 GHz          | 150 MHz   | Worldwide    |

* Digital Modulation and Demodulation

** Modulation Overview
- Modulation is the process of varying one or more properties of a periodic waveform, called the *carrier signal*, with a *modulating signal* that typically contains information to be transmitted. 
- In digital modulation, an *analog carrier signal* is modulated by a *discrete signal*.
- The most fundamental digital modulation techniques are based on keying:
  - ASK (amplitude-shift keying): *a finite number of amplitudes* are used.
  - FSK (frequency-shift keying): *a finite number of frequencies* are used.
  - PSK (phase-shift keying): *a finite number of phases* are used.
  - QAM (quadrature amplitude modulation): *a finite number of at least two phases and at least two amplitudes* are used.

*** Rectangle and Sinc Function

- The simplest digital signal is a rectangle function:
\[rect(x) = \begin{cases} 1 & x \in [-0.5,0.5]\\ 0 & otherwise \end{cases}.\]  
- Fourier Transform:
\[F(\omega ) = \int_{-\infty}^\infty f(t) \exp(2\pi i  \omega t)dt.\]
- The FT of rectangle function is (normalized) sinc function
\[sinc(\omega) = \frac{\sin(\pi*\omega)}{\pi*\omega}.\]

*** Rectangle and Sinc Function

#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/rect.js"

x = linspace(-2,2,5)
y = [1 if z <= 0.5 and z >= -0.5 else 0 for z in x]
p1 = figure(title = "Time Domain")
p1.step(x, y, line_width=2, mode="center")

x = linspace(-8,8,400)  
y = sinc(x)
p2 = figure(title = "Frequence Domain")
p2.line(x,y, line_width=2)

p = gridplot([p1, p2], ncols = 2, plot_width = width//2, plot_height = height)
js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/rect.js" id="a997696d-0ad0-4a34-9e26-1480eecbb1d3"></script>
#+end_export

*** Energy Spectrum of Rectangle Function
 
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/psd.js"
x = linspace(-5,5,400)  
y = sinc(x)
p = figure(title = "Energy Spectrum", plot_width = width, plot_height = height )
p.line(x, y**2, line_width=2)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/psd.js" id="64a91652-029f-4f4d-8e1a-66a66c172894"></script>
#+end_export

- Most of the energy are located inside the passband of \(\pm 1Hz\).
   
*** Properties of Fourier Transform
    
|                    | Time Domain                   | Frequency Domain                        |
| Linear Combination | \(a\times f(t)+b\times g(t)\) | \(a\times F(\omega)+b\times G(\omega)\) |
| Multiplication     | \( f(t)\times g(t)  \)        | \(F(\omega) * G(\omega)\)               |
| Delay              | \(f(t-\tau)\)                 |  \(\exp(-2\pi i \tau \omega) F(\omega)\) |

*** Modulation

- If we multiply the baseband signal (\(rect(t)\)) with a carrier signal (\(cos(2\pi f_0 t)\))

\[S(t) = rect(t)\times \cos (2\pi f_0 t). \]
- In frequency domain, the signal will be centered around the carrier frequency \(f_0\)
- Most of the energy is allocated inside \(f_0\pm 1\).
- If we reduce the symbol time from \(1s\) to \(\tau s\):
  - The modulated signal will still be centered around \(f_0\)
  - However, the zero crossing will happen at \(f_0 \pm 1/\tau\).
*** Modulation

#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/modulation.js"

x = linspace(-2,2,5)
y = [1 if z <= 0.5 and z >= -0.5 else 0 for z in x]
p1 = figure(title = "Time Domain")
p1.step(x, y, line_width=2, mode="center")

x = linspace(-20,20,400)  
y = sinc(x)
p2 = figure(title = "Frequence Domain")
p2.line(x, y, line_width=2)

x = linspace(-2,2,200)
y = cos(10*pi*x)
p3 = figure(title = "Time Domain")
p3.line(x,y, line_width=2)

x = [-5,5]
y = [.5, .5]
p4 = figure(title = "Frequence Domain")
p4.triangle(x, y, size=20)
p4.segment(x0 = x, y0 = y, x1 = x, y1 = [0,0], line_width=2)

x = linspace(-2,2,200)
y = [cos(10*pi*z) if z <= 0.5 and z >= -0.5 else 0 for z in x]
p5 = figure(title = "Time Domain")
p5.line(x, y, line_width=2)

x = linspace(-20,20,400)
y = sinc(x-5) + sinc(x+5)
p6 = figure(title = "Frequency Domain")
p6.line(x, y/2, line_width=2)

p = gridplot([p1, p3, p5, p2, p4, p6], ncols = 3, plot_width = width//3, plot_height = height//2)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/modulation.js" id="1915e652-39ea-489a-8e91-560227055c12"></script>
#+end_export

*** Demodulation
- The baseband signal can be recovered as
\begin{align*}
S(t) \times \cos(2\pi f_0 t) &= rect(t) \times \cos^2(2\pi f_0 t)\\
&= \frac{1}{2} rect(t) \times \left[1+\cos(4\pi f_0 t)\right] 
\end{align*}
- A low pass filter can be used in order to:
  - Filter out the high frequency \(rect(t) \times \cos(4\pi f_0 t)\) component;
  - And recover the baseband signal \(rect(t)\).

*** Demodulation
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/demodulation.js"

x = linspace(-2,2,5)
y = [1 if z <= 0.5 and z >= -0.5 else 0 for z in x]
p1 = figure(title = "Time Domain")
p1.step(x, y, line_width=2, mode="center")

x = linspace(-20,20,400)  
y = sinc(x)
p2 = figure(title = "Frequence Domain")
p2.line(x, y, line_width=2)

x = linspace(-2,2,200)
y = [cos(10*pi*z) if z <= 0.5 and z >= -0.5 else 0 for z in x]
p3 = figure(title = "Time Domain")
p3.line(x, y, line_width=2)

x = linspace(-20,20,400)
y = sinc(x-5) + sinc(x+5)
p4 = figure(title = "Frequency Domain")
p4.line(x, y/2, line_width=2)

x = linspace(-2,2,400)
y = [cos(10*pi*z)**2 if z <= 0.5 and z >= -0.5 else 0 for z in x]
p5 = figure(title = "Time Domain")
p5.line(x, y, line_width=2)

x = linspace(-20,20,400)
y = sinc(x-10) + 2*sinc(x) +  sinc(x+10)
p6 = figure(title = "Frequency Domain")
p6.line(x, y/2, line_width=2)

p = gridplot([p1, p3, p5, p2, p4, p6], ncols = 3, plot_width = width//3, plot_height = height//2)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/demodulation.js" id="b2d5c9c1-cca2-4837-828a-b7dfa9dc9be0"></script>
#+end_export

** Amplitude-Shift Keying
   
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/ask.js"
x0 = linspace(0, 12, 13)
y0 = [0,0,1,1,0,1,0,0,0,1,1,0,0]
p1 = figure(title = "Baseband Signal")
p1.step(x0, y0, line_width=2, mode="after")

x = linspace(0, 12, 241)
y = [step_func(p, x0, y0) * sin(2*pi*p) for p in x]
p2 = figure(title = "On-off Keying")
p2.line(x, y, line_width=2)

x1 = linspace(0, 11, 12)
y1 = [0,0,3,3,1,1,0,0,1,1,2,2]
y = [(step_func(p, x1, y1)+1) * sin(2*pi*p) for p in x]
p3 = figure(title = "4-ASK")
p3.line(x, y, line_width=2)

p = gridplot([p1, p2, p3], ncols = 1, plot_width = width, plot_height = height//3)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/ask.js" id="57f36ac7-2619-49c4-86b3-5664001755d1"></script>
#+end_export

*** Amplitude-Shift Keying
- We are allocated with a frequency band between 200-300kHz. If we use 4-ASK modulation scheme: 
  - What is the carrier frequency?
  - What is the symbol rate per second?
  - What is the bit rate per second?

** Frequency-Shift Keying
   

#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/fsk.js"
x0 = linspace(0, 12, 13)
y0 = [0,0,1,1,0,1,0,0,0,1,1,0,0]
p1 = figure(title = "Baseband Signal")
p1.step(x0, y0, line_width=2, mode="after")

x = linspace(0, 12, 241)
y = [step_func(p, x0, y0) * sin(4*pi*p) + (1-step_func(p, x0, y0)) * sin(2*pi*p) for p in x]
p2 = figure(title = "Frequency-Shift Keying")
p2.line(x, y, line_width=2)

p = gridplot([p1, p2], ncols = 1, plot_width = width, plot_height = height//2)
js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/fsk.js" id="9183530f-b130-491e-b59b-5ab7c3275556"></script>
#+end_export

*** Frequency-Shift Keying
- In practice, we can smooth the digital signal 
  - e.g., by Gaussian filter
  - the frequency changes more smoothly rather than instantaneously
  - to reduce sideband power
- We are allocated with a frequency band between 200-300kHz. If we use FSK modulation scheme: 
  - What are the sub-carrier frequencies if we assume that we use two frequencies that are 10Mhz apart?
  - What is the bit rate per second?

** Phase-Shift Keying
   
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/psk.js"
x0 = linspace(0, 12, 13)
y0 = [0,0,1,1,0,1,0,0,0,1,1,0,0]
p1 = figure(title = "Baseband Signal")
p1.step(x0, y0, line_width=2, mode="after")

x = linspace(0, 12, 241)
y = [(1-2*step_func(p, x0, y0)) * sin(2*pi*p) for p in x]
p2 = figure(title = "Binary PSK")
p2.line(x, y, line_width=2)

x1 = linspace(0, 11, 12)
y1 = [0,0,3,3,1,1,0,0,1,1,2,2]
y = [sin(2*pi*p+pi/4 + pi/2*step_func(p,x1,y1)) for p in x]
p3 = figure(title = "Quadrature-PSK")
p3.line(x, y, line_width=2)

p = gridplot([p1, p2, p3], ncols = 1, plot_width = width, plot_height = height//3)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/psk.js" id="38f59171-08ea-4216-aff4-fadfde45d94d"></script>
#+end_export
 
** QAM
 
*** Constellation Diagram
   
- We could draw the amplitude and phase of the symbol on the complex plane:
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/constellation.js"
x = [0,1]
y = [0,0]
rx = cos(linspace(0,2*pi,200))
ry = sin(linspace(0,2*pi,200))
p1 = figure(title = "OOK")
p1.circle(x, y, size = 20)
p1.line(rx, ry, line_dash = 'dotted')

x = [1,-1]
y = [0,0]
p2 = figure(title = "BPSK")
p2.circle(x, y, size = 20)
p2.line(rx, ry, line_dash = 'dotted')

x = cos(linspace(pi/4,pi/4*7,4))
y = sin(linspace(pi/4,pi/4*7,4))
p3 = figure(title = "QPSK")
p3.circle(x, y, size = 20)
p3.line(rx, ry, line_dash = 'dotted')

p = gridplot([p1, p2, p3], ncols = 3, plot_width = width//3, plot_height = width//3)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/constellation.js" id="2835d487-001d-4fbd-82ff-f89ca064fd76"></script>
#+end_export

*** Quadrature Amplitude Modulation (QAM)
- We could combine multiple amplitude and multiple phase together to form a constellation
- The most common ones are 16, 64, 256 QAM
  - each symbol carries 4, 6, 8 bits repsectively
  
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/qam.js"
x = linspace(-3,3,4)
y = linspace(-3,3,4)
xx, yy = meshgrid(x, y)
p1 = figure(title = "16-QAM")
p1.circle(xx.flatten(), yy.flatten(), size = 20)

x = linspace(-5,5,6)
y = linspace(-5,5,6)
xx, yy = meshgrid(x, y)
p2 = figure(title = "64-QAM")
p2.circle(xx.flatten(), yy.flatten(), size = 10)

x = linspace(-7,7,8)
y = linspace(-7,7,8)
xx, yy = meshgrid(x, y)
p3 = figure(title = "256-QAM")
p3.circle(xx.flatten(), yy.flatten(), size = 10)
p = gridplot([p1, p2, p3], ncols = 3, plot_width = width//3, plot_height = width//3)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/qam.js" id="cbc7e569-2482-4b38-9372-ef840a15eeb8"></script>
#+end_export

- For Wifi 6, up to 1024-QAM can be used depending on the channel quality
- Can we use "infinite"-QAM to transmit at "infinite" bit rate?

* Free Space Propagation Model
  
** Free Space Loss

*** Channel Impairments
- *Free space loss*
- *Noise*
- Fading 
  - Multi-path (Next Section)
- Atmospheric absorption

*** Free Space Transmission
    {{{revealimg("./figures/freespace.meta",t,"60vh")}}}

*** Friis Transmission Equation

- Friss Transmission Equation:
 \[\frac {P_r}{P_t}=D_rD_t\left(\frac {\lambda}{4\pi d}\right)^2.\]
- where:
  - \(P_{t}\) is the power fed into the transmitting antenna input terminals;
  - \(P_{r}\) is the power available at receiving antenna output terminals;
  - \(D_{r}, D_t\) are the antenna directivities (with respect to an isotropic radiator) of the transmitting and receiving antennas respectively;
  - \(d\) is the distance between antennas;
  - \(\lambda\) is the wavelength of the radio frequency;

#+REVEAL: split
- Friss Transmission Equation:
 \[\frac {P_r}{P_t}=D_rD_t\left(\frac {\lambda}{4\pi d}\right)^2.\]
- To increase signal strength at the receiving end:
  - Increase transmitting power; 
  - Decrease carrier frequency, distance;
  - Better antenna
    
** Noise
- Thermal Noise(John-Nyquist Noise)
  - Noise seen in switching circuits due to electrons
- Inter-modulation noise
  - Noise caused by signals at different frequencies on the same medium
- Crosstalk
  - coupling between signal paths
- Impulse Noise
  - Power spike (e.g. from thunder)

*** Thermal Noise

- White noise since it contains the same level of power at all frequencies
 \[N = ktB\]
- \(k\) is the Boltzmann’s constant: \(1.381\times 10^{-21} W/(K\cdot Hz)\),
- \(T\) is the absolute temperature in Kelvin, and
- \(B\) is the bandwidth.
- At room temperature, \(T = 290K\), the thermal noise power spectral density
  \(kT =  –174 dBm/Hz\)
- dBm is the ratio between the power and a reference of one milliwatt (mW), expressed in dB.
  - 0dBm = 1mW, 10dBm = 10mW, 20dBm = 100mW
- For 1MHz bandwidth, the power of the noise is
\(-174 + 10 log 1M= -114dBm\) or \(4\times 10^{-15}W\).

*** Thermal Noise

#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/thermalnoise.js"

from scipy import signal
t = linspace(0,5,501)
y = random.randn(len(t))
p1 = figure(title = 'White Noise')
p1.line(t,y)

f, Pxx_den = signal.welch(random.randn(100000), 1024, nperseg=1024)
p2 = figure(title = 'Power Spectra Density')
p2.line(f[1:-1],Pxx_den[1:-1])
p2.y_range=Range1d(0, max(Pxx_den))

p = gridplot([p1, p2], ncols = 1, plot_width = width, plot_height = height//2)
js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/thermalnoise.js" id="1adce4e0-31e9-412d-a453-98e15dd2c203"></script>
#+end_export

*** Constellation Diagram with Noise
    
#+BEGIN_leftcol

#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/qam2.js"
x = linspace(-3,3,4)
y = linspace(-3,3,4)
xx, yy = meshgrid(x, y)
p = figure(title = "16-QAM",  plot_width = width//3, plot_height = width//3)
p.circle(xx.flatten(), yy.flatten(), size = 20)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/qam2.js" id="a1f298ff-27a7-4e56-8ecb-23d2a95fc3b5"></script>
#+end_export

#+END_leftcol

#+BEGIN_rightcol
    {{{revealimg("./figures/16qam.meta",t,"60vh")}}}
#+END_rightcol
 
** Channel Capacity

*** Basic of Detection Theory
- Assuming we are using BPSK.

- At the receiving end, we get the following signals:
\[y = x + w =  \pm a + w,\]
  - \(a^2\) can be viewed as the energy of the received signal
  - \(w\sim \mathcal N(0,N_0)\) is a zero mean Gaussian noise, with average energy \(N_0\)
  - The Signal to Noise Ratio (SNR) can be defined as \(SNR = a^2/N_0\).
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/binarydetection.js"

x = array([0, 0])
y = array([0, 0.5])
p = figure(title = "Detection of BPSK", plot_width = width, plot_height = height//2)
p.line(x+1, y, line_width = 2, line_dash = 'dotted')
p.line(x-1, y, line_width = 2, line_dash = 'dotted')

x = linspace(-3,3,121)
y = exp(-x**2/2)/sqrt(2*pi)

p.line(x-1, y, line_width=2)
p.line(x+1, y, line_width=2)
xx = x[-41:-1]-1
yy = y[-41:-1]
xx = hstack((xx[0:1], xx))
yy = hstack(([0], yy))
#p.patch(xx, yy, hatch_pattern="/")
xx = x[0:41]+1
yy = y[0:41]
xx = hstack((xx,xx[-1:]))
yy = hstack((yy,[0]))
#p.patch(xx,yy, hatch_pattern="\\")
js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/binarydetection.js" id="ca85152c-99bf-4f0b-9413-4502c0bba93e"></script>
#+end_export

*** Probability of Error
- We need to estimate ("detect") the phase of \(x\) 
- The probability of error is
\[P_e = P(\hat x \neq x).\]
- Bayesian Detector:
  - Calculate the conditional probability
  \begin{align*}
  P(x = a|y)  &= \frac{P(x = a)P(y|x = a)}{P(y)},\\
  P(x =- a|y) &= \frac{P(x = -a)P(y|x =- a)}{P(y)}.
  \end{align*}
  - If \(P(x=a|y)\geq P(x=-a|y)\), then \(\hat x = 0\), otherwise \(\hat x = \pi\).
  
*** Probability of Error
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/binarydetection2.js"

x = array([0, 0])
y = array([0, 0.5])
p = figure(title = "Detection of BPSK", plot_width = width, plot_height = height//2)
#p.line(x+1, y, line_width = 2, line_dash = 'dotted')
#p.line(x-1, y, line_width = 2, line_dash = 'dotted')

x = linspace(-3,3,121)
y = exp(-x**2/2)/sqrt(2*pi)

p.line(x-1, y, line_width=2)
p.line(x+1, y, line_width=2)
xx = x[-41:-1]-1
yy = y[-41:-1]
xx = hstack((xx[0:1], xx))
yy = hstack(([0], yy))
p.patch(xx, yy, hatch_pattern="/")
xx = x[0:41]+1
yy = y[0:41]
xx = hstack((xx,xx[-1:]))
yy = hstack((yy,[0]))
p.patch(xx,yy, hatch_pattern="\\")
js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/binarydetection2.js" id="aeb02283-bfc9-4eb5-abb6-247f91de5956"></script>
#+end_export

- Assuming \(\pm a\) has equal probability, then the decision rule is 
\[\hat x = \begin{cases} 0 & if\;y\geq 0\\ \pi& otherwise\end{cases}.\]

#+REVEAL: split
- The probability of error is given by
\begin{align*}
P_e &= \int_{a}^{\infty} \frac{1}{\sqrt{2 \pi N_0}}\exp\left(-x^2/2N_0\right) dx \\
&= \int_{a/\sqrt {N_0}}^\infty\frac{1}{\sqrt{2\pi}} \exp\left(-x^2/2\right)dx\\
&=Q(\sqrt{SNR}).
\end{align*}

*** Encoding/Decoding
- To reduce bit error rate, one could
  - increase the SNR.
  - However, this is very expensive
- More clever solution:
  - We could transmit the same bit multiple times (repetition code)
  - or better yet, use error correct code
- Problem: If we use "higher" QAM (assuming the same average signal energy)
  - we pack more symbols into the same area in the constellation diagram
  - the symbols are more difficult to differentiate -> higher error rate per symbol
  - However, we could use better encoder to reduce the bit error rate
  - Can we achieve *infinite bit rate* (under some constraints on bit error rate)?

*** Shannon-Hartley Theorem 

\[C = B \times log_2( 1 + S/N ) = B \times log_2( 1 + SNR )\]

- where:
  - \(C\) the information rate of data that can be communicated at an arbitrarily low error rate;
  - \(B\) is the bandwidth of the channel in hertz;
  - \(S\) is the average received signal power over the bandwidth measured in watts; and
  - \(N\) is the average power of the noise and interference over the bandwidth, measured in watts.
- Fundamental limit: We *CANNOT* achieve a data rate higher than \(C\) *regardless of modulation/encoding* scheme.
- Achievability: For any data rate lower than \(C\), there *exists* a modulation/encoding scheme to achieve it.
  - Problem: the computational complexity is usually very high
  - Polar code is the first capacity-achieving code with complexity of \(O(n\log n)\).

*** Shannon-Hartley Theorem
 
\[C = B \times log_2( 1 + S/N ) \]

#+BEGIN_leftcol
- What if we increase the bandwidth \(B\)?
- The noise \(N = kTB = N_0B\) will also increase!
- The maximum capacity is still bounded by \(\log_2(e) S/N_0 \approx 1.44 S/N_0\).
 
#+END_leftcol
#+BEGIN_rightcol

#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/capacityvsbandwidth.js"

x = linspace(0.1,20,101)
y = [b*log2(1+1/b) for b in x]
p = figure(title = "AWGN Channel Capacity for S/N0 = 1", plot_width = width//2, plot_height = height)
p.line(x, y, line_width=2)
p.xaxis.axis_label = "Bandwidth"
p.yaxis.axis_label = "Channel Capacity"
js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/capacityvsbandwidth.js" id="33fe108e-f061-4641-b710-c2cff0a32435"></script>
#+end_export

#+END_rightcol

*** Shannon-Hartley Theorem

\[C = B \times log_2( 1 + SNR )\]
- Even SNR is very bad, we can still have reliable communication:
\[C = B \times log_2( 1 + SNR ) \approx \log_2(e) B \times SNR. \]
- Example: GPS communication
  - \(B\): 1 MHz bandwidth,
  - \(SNR\): −30 dB, the signal is 1000 times smaller than noise!
  - \(C \approx 1.44\times 10^6 \times 10^{-3} = 1440 bit/s\)
- Navigation message of GPS is sent at 50 bit/s
  - reliable communication can be established.

*** Implications
- Good physical layer protocol for intelligent networked system:
  - Long Range
  - High Throughput
  - Low Power
  - Other metrics: low latency, mobility, cost, ...
- Shannon-Hartley Theorem & Friis transmission equation: NO communication scheme can achieve long range, high throughput and low power simultaneously.
- Need to consider applications:
  - Surveillance camera for smart city: long range, high throughput
  - Environmental monitoring: long range, low power
  - Smart Building: short range

* Multi-Path Problem 
 
** Multi-path
   
*** Impairments
- Free space loss
- Noise
- Fading 
  - *Multi-path*
- Atmospheric absorption

*** Multi-path
- Multi-path: obstacles reflect signals so that multiple copies with varying delays are received
  - Reflection - occurs when signal encounters a surface that is large relative to the wavelength of the signal
  - Diffraction - occurs at the edge of an impenetrable body that is large compared to wavelength of radio wave
  - Scattering – occurs when incoming signal hits an object whose size in the order of the wavelength of the signal or less

*** Reflecting Wall Example cite:Tse2005
 
#+BEGIN_leftcol
- Assuming a single frequency \(f\) sinusoidal signal is transmitted
- The direct signal has a phase delay of 
\[\phi_1 =  \frac{2\pi}{c}rf.\]
- The reflected signal has a phase delay of 
\[\phi_2 =  \frac{2\pi}{c}(2d-r)f.\]
  
#+END_leftcol
#+BEGIN_rightcol
  {{{revealimg("./figures/multipath.meta","Reflecting Wall Example","40vh",nil,'none)}}}
- The phase difference of the two signal is
  \[\Delta \phi = \frac{4 \pi}{c} (d-r)f.\]
#+END_rightcol

** Coherence Bandwidth

- The difference between the max and min delay is called delay spread. In our case,
  \[T_d = \frac{2(d-r)}{c}.\]
- If the frequency changes by \(1/2T_d\), then the phase difference changes by \(\pi\).
- \(W_c = 1/2T_d\) is called coherence bandwidth.
- For cellular communication, the path length difference is usually less than 300m
- The delay spread is \(300m/c = 1\mu s\)
- The coherence bandwidth is \( (2 \mu s)^{-1} = 500 KHz\).
*** Flat v.s. Frequency Selective Fading
- *Flat fading*: \(W_c\) is much larger than the bandwidth of the signal. 
  - All frequency components of the signal will experience the same magnitude of fading.
  - Narrowband signal: GSM use 200kHz sub-channel
- *Frequency-selective fading*: \(W_c\) is smaller than the bandwidth of the signal.
  - Different frequency components of the signal experience different fading.
  - Countermeasures: equalization, ...
  - Wideband signal: cdmaOne uses 1.25Mhz
*** Flat v.s. Frequency Selective Fading cite:Tse2005

  {{{revealimg("./figures/freqfading.meta","Impulse Response of a Fading Channel","60vh",nil,'none)}}}

*** Intersymbol Interference

- Delay causes copies of the signal arriving at the receiver at different times
- Part or all of a given symbol will be spread into the subsequent symbols
  - Interfering with the correct detection of those symbols
- To avoid ISI, symbol duration needs to be much larger than delay spread
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/fskwithisi.js"
x0 = linspace(0, 12, 13)
y0 = [0,0,1,1,0,1,0,0,0,1,1,0,0]
p1 = figure(title = "Baseband Signal")
p1.step(x0, y0, line_width=2, mode="after")

x = linspace(0, 12, 241)
y = [step_func(p, x0, y0) * sin(4*pi*p) + (1-step_func(p, x0, y0)) * sin(2*pi*p) for p in x]
y = array(y)
p2 = figure(title = "Frequency-Shift Keying")
p2.line(x, y, line_width=2)

p3 = figure(title = "Delayed Signal")
p3.line(linspace(1, 12, 221), y[0:221]/2, line_width=2, line_dash = 'dashed')
p3.line(linspace(1.2, 12, 217), y[0:217]/2, line_width=2)

p4 = figure(title = "Combined Signal")
p4.line(linspace(1, 12, 221), y[0:221]/2 + hstack((zeros(4),y[0:217]/2)), line_width=2)

p = gridplot([ p3, p4], ncols = 1, plot_width = width, plot_height = height//3)
js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/fskwithisi.js" id="be337c6e-6ef9-41bc-a8ae-6fb167bbb78e"></script>
#+end_export

** Coherence Time

+ Recall that phase difference of the two signal is
  \[\Delta \phi = \frac{4 \pi}{c} (d-r)f.\]
+ If the frequency is fixed, then the phase changes \(\pi\) if the receiver moves
\[\Delta r = c/4f.\]
  - For a carrier frequency of 1GHz, \(\Delta r \approx 7.5 cm\).
+ Consider we are on a vehicle at speed \(60km/h \approx 16.7m/s\)
  - It takes 4.5ms for \(\Delta \phi\) to change \(\pi\)
  - This time is called coherence time 
*** Fading 
    
#+BEGIN_leftcol
- If we assume:
  - the initial path length difference \(2(d-r_0) = 300m\);
  - the base frequency \(f_0 = 1GHz\);
  - moving speed of 10m/s.

#+END_leftcol

#+BEGIN_rightcol

#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/fading.js"
f0 = 1e9
f = linspace(0, 2e6, 50 ) + f0
d0 = 300
v = 10
t = linspace(0, 10e-2, 150)
d = d0 + 2*v*t 
c = 3e8 
dd, ff = meshgrid(d, f)
amp = 1 + cos(ff*dd*2*pi/c)

p = figure(tooltips=[("t", "$x"), ("f", "$y"), ("value", "@image")])
p.x_range.range_padding = p.y_range.range_padding = 0

p.image(image=[amp], x=0, y=1000, dw=30, dh=2, palette="Greys256", level="image")
p.xaxis.axis_label = "Time(ms)"
p.yaxis.axis_label = "Frequncy(MHz)"
js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/fading.js" id="a37ee54a-92e2-4dbf-a970-aacdcd06b46c"></script>
#+end_export

#+END_rightcol
*** Real World Fading 
    {{{revealimg("./figures/realfading.meta",t,"60vh")}}}

* Diversity
** Time Diversity 
 
- Wireless communication is usually an underspread channel
  - Delay spread (\(\mu s\)) is much smaller than coherence time (ms)
  - A narrowband signal (flat-fading) can transmit hundreds of symbols during a coherent time window 
- To ensure that the coded symbols are transmitted through independent or nearly independent fading gains, we can interleave the code.
- Drawbacks: may results in large latency
- GSM use TDMA for voice communication

*** Time Diversity 
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/timediversity.js"

x = linspace(0,16,5)
y = array([3, 2, .1, 1, 1])
p1 = figure()
p1.step(x, y, line_width=2, mode="after")
p1.yaxis.axis_label = "Gain"

p2 = figure()
p2.axis.visible = False
p2.xgrid.visible = False
p2.ygrid.visible = False
color = Category10_10.__iter__()
c = next(color)
for i in range(0,4):
    c = next(color)
    for j in range(0,4):
        center = 4*i + j + 0.5
        p2.rect(x = center ,y= 0.5,width=1,height=1, fill_color=c)

p3 = figure()
p3.axis.visible = False
p3.xgrid.visible = False
p3.ygrid.visible = False
p3.xaxis.axis_label = "Time"
color = Category10_10.__iter__()
c = next(color)
for i in range(0,4):
    c = next(color)
    for j in range(0,4):
        center = 4*j + i + 0.5
        p3.rect(x = center ,y= 0.5,width=1,height=1, fill_color=c)

p = gridplot([p1, p2, p3], ncols = 1, plot_width = width, plot_height = height//3)
js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html
<script src="figures/timediversity.js" id="65798b42-a9cf-4f29-9b81-f2439d9b48f2"></script>
#+end_export

** Space Diversity: MIMO
   
- Multiple antenna can be used at the transmitting and receiving end
- Instead of destructive fading, we can achieve constructive fading
  {{{revealimg("./figures/spacediversity.meta","SIMO\, MISO and MIMO","60vh",nil,'none)}}}

** Frequency Diversity   
  
*** Spread Spectrum
- Spread-spectrum: a signal with a particular bandwidth is deliberately spread in the frequency domain, resulting in a signal with a wider bandwidth. 
- Benefits
  - Frequency diversity: not all frequencies are in deep fade
  - Used for hiding and encrypting signals 

*** Chirp Spread Spectrum 
- A chirp is a sinusoidal signal of frequency increase or decrease over time
- Idea for low energy communication protocols
  - e.g. LoRa
 
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/chirp.js"

x = linspace(0,1,500)
y = sin(50*pi*x**2)
p1 = figure(title = "Upchirp")
p1.line(x,y, line_width=2)
p2 = figure(title = "Downchirp")
p2.line(x[::-1],y, line_width=2)

p = gridplot([p1, p2], ncols = 2, plot_width = width//2, plot_height = height//2)
js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/chirp.js" id="d5b7eae5-8c25-415d-95a9-8270a2fb7e3e"></script>
#+end_export

*** Direct Sequence Spread Spectrum
- Information is encoded and modulated by a pseudonoise (PN) sequence
- The data rate \(R\) is much smaller than the transmission bandwidth \(W\) Hz
  - e.g., cdmaOne use a bandwidth of 1.2288 MHz 
  - and a typical data rate (voice) is 9.6 kbits/s
  - The processing gain is \(1228.8/9.6 = 128\)
  - 64 chips are used for 1 data bit

*** Direct Sequence Spread Spectrum
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/dhss.js"
x = linspace(0,32,33)
y = array([1 if z <= 16 else 0 for z in x])
p1 = figure(title = "Baseband Signal")
p1.step(x, y, line_width=2, mode="before")
pn = array([round(p) for p in random.rand(16)])
pn = hstack((pn,pn,pn[:1]))
p2 = figure(title = "PN Sequence")
p2.step(x, pn, line_width=2, mode="before")
encode = 0.5 + 2*(y-0.5)*(pn-0.5)
p3 = figure(title = "Transmitted Signal")
p3.step(x, encode, line_width=2, mode="before")

p = gridplot([p1, p2, p3], ncols = 1, plot_width = width, plot_height = height//3)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/dhss.js" id="7981e84f-bf2d-4e75-8815-b5b99baa9965"></script>
#+end_export

*** Direct Sequence Spread Spectrum 
- How to combat Intersymbol interference:
  - The shifted PN sequence is "orthogonal" to the original sequence

#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/dhss2.js"

p1 = figure(title = "PN Sequence")
p1.step(x, pn, line_width=2, mode="before")

p1.x_range=Range1d(0, 32)
p2 = figure(title = "Delayed Signal")
p2.step(x[1:], encode[:-1], line_width=2, mode="before")

p2.x_range=Range1d(0, 32)

decode = 0.5 + 2*(pn[1:]-0.5)*(encode[:-1]-0.5)
p3 = figure(title = "Decoded Signal")
p3.step(x[1:], decode, line_width=2, mode="before")

p3.x_range=Range1d(0, 32)
p = gridplot([p1, p2, p3], ncols = 1, plot_width = width, plot_height = height//3)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/dhss2.js" id="0876ce05-a29c-46dd-844e-eb363637b629"></script>
#+end_export

*** Frequency Hopping Spread Spectrum
- Frequency-hopping spread spectrum is a method of transmitting radio signals by *rapidly changing the carrier frequency* among many distinct frequencies occupying a large spectral band
  - e.g. Bluetooth LE uses 37 channels, each occupy 2MHz
  - Channels are switched at a rate of 1600 hops/s (\(625\mu s\)).
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/fhss.js"
p = figure(title="Frequency Hopping Spread Spectrum", plot_width = width, plot_height = height//2)

for f in range(0,5):
    for t in range(1,10):
        p.rect(x=t,y=f,width=0.9,height=0.9, fill_color="#ffffff")

for t in range(1,10):
    f = random.randint(5)
    p.rect(x=t,y=f,width=0.9,height=0.9, fill_color="#cab2d6")

p.xaxis.axis_label = "Time"
p.yaxis.axis_label = "Frequency"
js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/fhss.js" id="0ae8eabf-3e79-4517-b45f-49121d4fab50"></script>
#+end_export
   
*** Orthogonal Frequency Division Multiplexing
- Consider the Bluetooth LE example
  - Assuming a symbol rate of \(R\)
  - The corresponding \(sinc\) function will occupy \(2R\) bandwidth
  - Hence, \(2R + guard\;band\leq 2MHz\)
- Is it really necessary?   
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/fdma.js"
x = linspace(-0.7,0.7,51)
y = sinc(x/0.7)
p = figure(title = "Frequency Division", plot_width = width, plot_height=height//2)
for i in range(1,10):
    p.patch(x+2*i, y, line_width=2)

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/fdma.js" id="bd08ef7f-2af1-4651-a19e-d916308b8e00"></script>
#+end_export

*** Orthogonal Frequency Division Multiplexing
#+BEGIN_SRC ipython :session :exports results :results output html :var filename="figures/ofdm.js"
x = linspace(-3, 7, 501)
symbol = array([round(x)*2 -1 for x in random.rand(5)])
p = figure(title = "Orthogonal Frequency Division Multiplexing", plot_width = width, plot_height=height)
color = Category10_10.__iter__()
for i in range(5):
    p.line(x, symbol[i]*sinc(x-i), line_width=1, color = next(color))
    
from functools import reduce
y = reduce(lambda x,y:x+y, map(lambda i: symbol[i]*sinc(x-i), range(5)))
p.line(x, y, line_width=3, color = next(color))
p.circle(range(5), symbol, size=10, fill_alpha=.5, color = next(color)) 

js, tag = autoload_static(p, CDN, filename)
f = open(filename, "w")
f.write(js)
f.close()

print(tag)
#+END_SRC

#+RESULTS:
#+begin_export html

<script src="figures/ofdm.js" id="8fc043ff-2f85-438d-97f0-57da35d415f9"></script>
#+end_export

*** Orthogonal Frequency Division Multiplexing
    
- \(sinc(x + k),\, k\in\mathbb Z\) are orthogonal to each other
- For the OFDM scheme
  - If the symbol rate is \(R\)
  - Each sub-carrier signal only needs to be \(R\) apart
  - More than twice spectral efficient
  - Modulation/Demodulation can be done efficiently via Fast Fourier Transform
- OFDM is originally proposed by Bell lab in 1966
- Used in Wifi, 4G, 5G

* Physical Layer Protocol
** Bluetooth LE
  
- Bluetooth is a low-power wireless connectivity technology {{{reveallicense("./figures/bluetooth.meta","20vh")}}}
  - cell phones sensors
  - headsets
  - keyboards/mouses
  - video game systems
- The name Bluetooth refers to King Harald Blatand in the region of what is now Norway and Sweden in around 958AD.
  - He got this name due to his liking of blueberries and/or the eating of his frozen enemies.
  - Bluetooth is derived from his name because King Blatand brought together warring tribes.
- Bluetooth Low Energy is used extensively in IoT deployments 
  - beacons
  - wireless sensors
  - asset tracking systems
  - remote controls
  - health monitors
  - and alarm systems.
- Throughout its history, Bluetooth and all the optional components have been under GPL license and are essentially open source.

*** PHY of Bluetooth LE

- Operates in the 2.400–2.4835 GHz ISM band (Same as Wifi and 802.15.4)
- The ISM band is divided into forty 2-MHz channels.
  - 37 of the channels are used to transmit date
  - 3 channels are reserved for advertising
  - frequency hopping is used to provide diversity
- Within a channel, data is transmitted using Gaussian FSK modulation
- The bit rate is 1 Mbit/s, and the maximum transmit power is 10 mW 
  - Can be increased to 2Mbit/s and 100 mW in Bluetooth 5

*** PHY of Bluetooth LE cite:Lea2018

  {{{revealimg("./figures/ble.meta","Bluetooth Low Energy Channels","60vh",nil,'none)}}}

*** Comparison between Bluetooth and Bluetooth LE
| Technical specification           | Bluetooth            | Bluetooth Low Energy technology     |
| Distance/range (theoretical max.) | 100 m                | <100 m                              |
| Over the air data rate            | 1–3 Mbit/s           | 125k – 500k – 1M – 2 Mbit/s         |
| Power consumption                 | 1 W as the reference | 0.01–0.50 W (depending on use case) |
| Peak current consumption          | <30 mA               | <15 mA                              |

** IEEE 802.15.4
- The IEEE 802.15.4 is a standard wireless personal area network (PAN) defined by the IEEE 802.15 working group.
  - Defines the physical and MAC layer
  - basis of many other protocols: Thread, Zigbee, WirelessHART, and others.
- The goal is to develop a low-cost WPAN with low power consumption.   
- Operates in the ISM spectrum:
  - 868 MHz, 915 MHz, and 2400 MHz.

| Frequency range (MHz) | Channel numbers    | Modulation      | Data rate (Kbps) | Region                   |
|                 868.3 | 1 channel: 0       | BPSK/O-QPSK/ASK | 20/ 100 /250     | Europe                   |
|               902-928 | 10 channels: 1-10  | BPSK/O-QPSK/ASK | 40/250/250       | North America, Australia |
|             2405-2480 | 16 channels: 11-26 | O-QPSK          | 250              | Worldwide                |


*** PHY of IEEE 802.15.4 cite:Lea2018
- Direct Sequence SS/Chirp SS/Ultra-wideband can be used for diversity
- Typical range: 200 meters outdoors, 30m indoors
- Typical transmission current: 15~30 mA, and reception current: 18~37mA

  {{{revealimg("./figures/80215.meta","Bluetooth Low Energy Channels","60vh",nil,'none)}}}

** IEEE 802.11 (WiFi)
- First release in June 1997
- The newest is Wifi 6
  - Works in both 2.4Ghz and 5Ghz ISM band
  - Support up to 1024 QAM
  - Use OFDMA for spreading spectrum and multiple user access
  - Use Multi-user MIMO
*** Comparison between different generations of Wifi cite:Lea2018
  {{{revealimg("./figures/wifi.meta","Various IEEE 802.11 standards and specification","60vh",nil,'none)}}}

** Cellular Communication
- The International Telecommunication Union (ITU) is a UN specialized agency 
  - was founded in 1865
  - took its present name in 1932
  - before becoming a specialized agency in the UN.
- the Radio communication Sector (ITU-R) defines the international standards and goals for various generations of cellular communication. 
|                    | 2G         | 3G           | 4G                                   | 5G                                 |
| First Availability | 1999       | 2002         | 2010                                 | 2020                               |
| Bandwidth          | NA         | Stationary: 2Mbps Mobile 384Kbps | Stationary:1 Gbps, Mobile 100Mbps    | Min Down: 20 Gbps/ Min Up: 10 Gbps |
| Features           | Voice, SMS | Audio, Video | Unified IP and seamless LAN/WAN/WLAN | IoT, ultra density, low latency    |

*** 5G

1. Enhanced Mobile Broadband (eMBB):
   - 1 to 10 GBps connections to UEs/endpoints in the field (not theoretical)
   - 100% coverage across the globe (or perception of)
   - 10 to 100x the number of connected devices over 4G-LTE
   - Connectivity at a speed of 500 km/h
2. Ultra-Reliable and Low-Latency Communications (URLLC):
   - Sub < 1 ms end-to-end round-trip latency
   - 99.999% availability (or perception of)
3. Massive Machine Type Communications (mMTC):
   - 1000x bandwidth per unit area; this implies roughly 1 million nodes in 1 km 2
   - Up to a 10 year battery life on endpoint IoT nodes
   - 90% reduction in network energy usage

** LoRa
- LoRa is a physical layer for a *long-range* and *low-power* IoT protocol
- Originally developed by Cycleo in France and then acquired by the Semtech Corporation in U.S.
- ZTE and Alibaba are in the LoRa Alliance.
- Uses the following ISM band:
  - 915 MHz: In the USA
  - 868 MHz: In Europe
  - 433 MHz: In Asia.
- Chirp Spread Spectrum (CSS) is the modulation technique used in LoRa.
- Typical data rate is 0.3 - 5kbps
- Each LoRa packet contains 51-222 Bytes of Data
- Typical Energy for one message is < 1 \(\muAh\)
- Typical range of communication is 2-3km in cities and 5-7km in rural area
  - The world record is 702km!

** Comparison
- Good physical layer protocol for intelligent networked system:
  - Long Range
  - High Throughput
  - Low Power
  - Other metrics: low latency, mobility, cost, ...
- NO communication scheme can achieve long range, high throughput and low power simultaneously.
- Need to consider applications:
  - Surveillance camera for smart city: 4G/5G
  - Environmental monitoring: LoRa
  - Smart Building: 
    - WiFi for camera
    - 802.15.4/Bluetooth LE for temperature sensor

* Bibliography
  :PROPERTIES:
  :CUSTOM_ID: bibliography
  :END:

  printbibliography:references.bib

  # Local Variables:
  # indent-tabs-mode: nil
  # org-src-preserve-indentation: t
  # End:
